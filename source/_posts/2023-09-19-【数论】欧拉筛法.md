---
title: 【数论】欧拉筛法
date: 2023-09-19 20:13:08
tags: 
- Algorithm
categories:
- Major
- Algorithm
index_img: https://blog-pic-storage.oss-cn-shanghai.aliyuncs.com/img/202309192017040.png
excerpt: 欧拉筛法的实际应用
---

### 第2关：输出指定范围内的素数

- 编写一个能输出指定范围内的素数的小程序。

### 相关知识

- 为了完成本关任务，你需要掌握：如何判断一个正整数是否是素数。

**如何判断一个正整数是否是素数**

- 素数（Prime Number），又称质数，一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数；否则，称为合数（Composite Number）。1既不是素数，也不是合数。
- 如`2、3、5、7、11都是素数`，`因为找不到除了1和其本身之外的约数`；而`4、6、8都是合数`，`因为4可以整除2，6可以整除2和3，8可以整除2和4`。
- 根据上述定义，我们很容易写出判断一个素数是否是素数的代码：

```python
 def is_prime_1(x):
        if x == 1:
            return False
        for i in range(2, x):
            if x % i == 0:
                return False
        return True
1234567
```

- 假设一个正整数a，则其可以被写成任意两个正整数之积，即`a = p * q`，假设`p < q`，那么正整数`p`和`q`都是`a`的约数，注意到，如果我们知道`p`是`a`的约数，那么可以通过`q = a / p`快速求得另外一个约数`q`。所以，我们在判断质数的时候，只需要枚举2到不大于`sqrt(a)`的正整数即可。
- 虽然通过上述方法，已经能让我们在根号级别的复杂度内，判断一个正整数是否是素数，但如果我们要判断很多个数是否为素数呢？是否每次都需要枚举`int(sqrt(a)+1)`个数呢？回到我们最初的起点，我们之所以要枚举这些数，就是想找出原数的约数。然后除1外，任何一个正整数都能写成多个素数的乘积的形式，那么我们枚举特定范围内的所有素数，也能达到相同的效果，而且在判断多个正整数是否是素数的时候，我们只需要枚举更少的质因数与其比较。大家可以看下面不同区间内的素数统计结果：
  

> 从上图的统计结果我们可以发现，当区间越来越大，里面的素数个数和区间内所有数字的个数差距也越来越大。所以，我们用区间内的素数，去判断一个整数是不是素数，比较的次数将更少。

- 而求不超过某个正整数x内的所有素数，有一个著名的算法——埃拉托斯特尼筛法。其算法描述为：

> 1. 先用一个数组vis，把不大于该正整数x的所有正整数标记为0，表示没有访问；
> 2. 然后从第一个素数2开始遍历整个区间，如果当前访问的数没有访问过，则可以认为它是一个素数，那么就将它在该区间内所有的倍数全部标记为已访问，这样就保证外部的循环发现的没有访问过的数都是素数。

- 其具体实现如下述代码所示：

```python
def sieve(x):
    vis = [0 for i in range(x+1)]
    prime_table = []
    for i in range(2, x+1):
        if vis[i] == 0:
            prime_table.append(i)
            for j in range(i*2, x+1, i):
                vis[j] = 1
    return prime_table
123456789
```

> **然而，除了上述筛法，还有其他高效的筛法，比如欧拉筛法，这里只给出其代码实现，希望大家能仔细去体会。**

```python
def ouler(x):
    vis = [0 for i in range(x+1)]
    prime_table = []
    ln = 0
    for num in range(2, x+1):
        if vis[num] == 0:
            prime_table.append(num)
            ln += 1
        for j in range(ln):
            if num * prime_table[j] > x:
                break
            vis[num * prime_table[j]] = 1
            if num % prime_table[j] == 0:
                break
    return prime_table
123456789101112131415
```

### 编程要求

- 计算并输出指定范围内的所有素数

> 第一行输入正整数n，表示测试样例组数，接下来输入n行，每行输入两个正整数a和b，要求输出a和b之间（包括a和b）所有的素数，保证a<b，且b不超过10^7

> 测试输入：

```python
2
30,100
999670,1000000
123
```

> 预期输出：

```python
[31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
[999671, 999683, 999721, 999727, 999749, 999763, 999769, 999773, 999809, 999853, 999863, 999883, 999907, 999917, 999931, 999953, 999959, 999961, 999979, 999983]
12
```

上代码：

```python
class Solution():
    def solve(self, l, r):
        '''
        :type l, r: int
        :rtype : list
        '''
        #请在此添加代码，实现求得[l, r]范围内的所有素数，并将其返回
        #********** Begin *********#
        from math import sqrt
        #通过素数表判断整数是不是素数
        def is_prime(x):
            if x == 1:
                return False
            for num in prime_table:
                if num * num > x:
                    return True
                if x % num  == 0:
                    return False
        #欧拉筛法
        def ouler(x):
            vis = [0 for i in range(x+1)]
            prime_table = []
            ln = 0
            for num in range(2, x+1):
                if vis[num] == 0:
                    prime_table.append(num)
                    ln += 1
                for j in range(ln):
                    if num * prime_table[j] > x:
                        break
                    vis[num * prime_table[j]] = 1
                    if num % prime_table[j] == 0:
                        break
            return prime_table
        prime_table = ouler(10000)
        ans = []
        for num in range(l, r+1):
            if is_prime(num):
                ans.append(num)
        return ans
        #********** End *********#
```
